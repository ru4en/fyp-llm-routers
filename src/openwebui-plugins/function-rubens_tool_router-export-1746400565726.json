[{"id":"rubens_tool_router","user_id":"4227cc1d-492b-4ab3-8f2b-a7cc537e0e29","name":"Tool Router","type":"filter","content":"\"\"\"\ntitle: Tool Router\nauthor: Ruben Lopes (@ru4en)\ndescription: |\n    This is a simple tool router that uses a zero-shot classification model to route queries to the appropriate tool.\n    It uses the Hugging Face Transformers library for the zero-shot classification model.\n    The router can be used to route queries to different tools based on their descriptions.\n    The router can be used in a pipeline with other components.\nrequirements: pydantic, requests, git+https://github.com/ru4en/llm_routers.git\nversion: 1.0.0\n\"\"\"\n\nfrom llm_routers import ToolRouter\nimport sys\n\nfrom typing import Callable, Any, List, Dict, Optional, Tuple\nfrom pydantic import BaseModel, Field\nfrom open_webui.models.tools import Tools\nimport inspect\nimport asyncio\n\n\nclass EventEmitter:\n    \"\"\"\n    Helper wrapper for OpenWebUI event emissions.\n    \"\"\"\n\n    def __init__(\n        self,\n        event_emitter: Callable[[dict], Any] = None,\n        debug: bool = False,\n    ):\n        self.event_emitter = event_emitter\n        self._debug = debug\n        self._status_prefix = None\n        self._emitted_status = False\n\n    def set_status_prefix(self, status_prefix):\n        self._status_prefix = status_prefix\n\n    async def _emit(self, typ, data, twice):\n        if self._debug:\n            print(f\"Emitting {typ} event: {data}\", file=sys.stderr)\n        if not self.event_emitter:\n            return None\n        result = None\n        for i in range(2 if twice else 1):\n            maybe_future = self.event_emitter(\n                {\n                    \"type\": typ,\n                    \"data\": data,\n                }\n            )\n            if asyncio.isfuture(maybe_future) or inspect.isawaitable(maybe_future):\n                result = await maybe_future\n        return result\n\n    async def status(\n        self, description=\"Unknown state\", status=\"in_progress\", done=False\n    ):\n        self._emitted_status = True\n        if self._status_prefix is not None:\n            description = f\"{self._status_prefix}{description}\"\n        await self._emit(\n            \"status\",\n            {\n                \"status\": status,\n                \"description\": description,\n                \"done\": done,\n            },\n            twice=not done and len(description) <= 1024,\n        )\n\n    async def fail(self, description=\"Unknown error\"):\n        await self.status(description=description, status=\"error\", done=True)\n\n    async def clear_status(self):\n        if not self._emitted_status:\n            return\n        self._emitted_status = False\n        await self._emit(\n            \"status\",\n            {\n                \"status\": \"complete\",\n                \"description\": \"\",\n                \"done\": True,\n            },\n            twice=True,\n        )\n\n    async def message(self, content):\n        await self._emit(\n            \"message\",\n            {\n                \"content\": content,\n            },\n            twice=False,\n        )\n\n    async def citation(self, document, metadata, source):\n        await self._emit(\n            \"citation\",\n            {\n                \"document\": document,\n                \"metadata\": metadata,\n                \"source\": source,\n            },\n            twice=False,\n        )\n\n    async def code_execution(self, code_execution_tracker):\n        await self._emit(\n            \"citation\", code_execution_tracker._citation_data(), twice=True\n        )\n\n\nfeatured_tools: Dict[str, str] = {\n    \"web_search\": \"search the web for information\",\n    \"code_interpreter\": \"interpret or execute python code\",\n    # \"image_generation\": \"generate images if applicable\",\n}\n\n\nclass Filter:\n    emitter: EventEmitter = None\n\n    class Valves(BaseModel):\n        model: str = Field(\n            \"facebook/bart-large-mnli\",\n            description=\"The model to use for the zero-shot classification task.\",\n        )\n        n: int = Field(\n            3,\n            description=\"The number of tools to return.\",\n        )\n        threshold: float = Field(\n            0.8,\n            description=\"The threshold for tool selection.\",\n        )\n        # New parameter to control minimum probability for tool selection\n        min_probability: float = Field(\n            0.7,\n            description=\"The minimum probability required to return any tool. If the highest probability is below this, no tool will be returned.\",\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.tools = featured_tools\n        self.tool_router: ToolRouter = None\n\n    async def inlet(\n        self, body: dict, __event_emitter__: Callable[[dict], Any] = None\n    ) -> dict:\n\n        self.emitter = EventEmitter(__event_emitter__)\n        await self.emitter.status(\"Selecting tool...\", status=\"in_progress\", done=False)\n        self.tools = {\n            tool.id: tool.specs[0][\"description\"] for tool in Tools.get_tools()\n        }\n\n        self.tools.update(featured_tools)\n\n        self.tool_router = ToolRouter(\n            tools=self.tools,\n            model_name=self.valves.model,\n            threshold=self.valves.threshold,\n            top_n=self.valves.n,\n        )\n        print(f\"Tools: {self.tool_router.candidates}\")\n\n        query = body[\"messages\"][-1][\"content\"]\n        selected_tools = self.tool_router.route_query(query)\n        _tools_, prob = selected_tools[0] if selected_tools else (None, None)\n\n        self.emitter.set_status_prefix(\"Tool Router: \")\n        if _tools_ is None:\n            await self.emitter.status(\n                description=\"No tool selected\",\n                status=\"complete\",\n                done=True,\n            )\n        else:\n            await self.emitter.status(\n                description=f\"Selected {_tools_} with probability {prob}\",\n                status=\"complete\",\n                done=True,\n            )\n        print(\"===\" * 10)\n        print(f\"Selected tool: {_tools_}\\nProbability: {prob}\")\n        print(\"===\" * 10)\n\n        # Only add to features and tool_ids if a valid tool was selected\n        if _tools_ is not None:\n            if _tools_ in featured_tools:\n                body[\"features\"][_tools_] = True\n            body[\"tool_ids\"] = [_tools_]\n        else:\n            # Handle the case where no tool was selected\n            body[\"tool_ids\"] = []\n\n        return body\n\n    def stream(self, event: dict) -> dict:\n        return event\n\n    async def outlet(self, body: dict) -> dict:\n        return body\n","meta":{"description":"Tool Router","manifest":{"title":"Tool Router","author":"Ruben Lopes (@ru4en)","description":"|","requirements":"pydantic, requests, git+https://github.com/ru4en/llm_routers.git","version":"1.0.0"}},"is_active":true,"is_global":true,"updated_at":1746400560,"created_at":1745880447}]